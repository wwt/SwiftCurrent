@Tutorial(time: 30) {
    @Intro(title: "Core") {
        Core text
    }
    @Section(title: "What is a Workflow?") {
    
        @ContentAndMedia {
            In this section you'll learn what a workflow is under the covers. You'll be walked through ``SwiftCurrent/LinkedList``, `_WorkflowItem`, ``SwiftCurrent/FlowRepresentableMetadata``, ``SwiftCurrent/AnyWorkflow/PassedArgs``, and ``SwiftCurrent/Workflow``.
        }
        
        @Steps {
            @Step {
                Start with ``SwiftCurrent/LinkedList``.
                
                All workflows are doubly linked lists, so this data type is a great starting point. You'll notice that it partially mimics Swift sequence types, but is not a `Struct`. This is deliberate. We rely on inheritance logic and did not design this type so that anyone could use LinkedList outside of SwiftCurrent.
                
                @Code(name: "LinkedList.swift", file: "LinkedList.swift", reset: true)
            }
            
            @Step {
                ``SwiftCurrent/LinkedList/Node`` is the type used for the nodes in the linked list.
                
                Like any node in a linked list, ``SwiftCurrent/LinkedList/Node`` holds a reference to the value and the previous and next nodes in the linked list. It also has methods for traversing the list, starting at the current node.
                
                @Code(name: "LinkedListNode.swift", file: "LinkedListNode.swift", reset: true)
            }
            
            @Step {
                `_WorkflowItem` is the value type for each node.
                
                Because ``SwiftCurrent/Workflow`` is a doubly linked list, each node in a workflow needs a value type. This value type is `_WorkflowItem`. This type holds onto 2 important things. **First,** ``SwiftCurrent/FlowRepresentableMetadata`` for this node. We will explore this type in the next step. **Second,** an instance of the ``SwiftCurrent/AnyFlowRepresentable`` if one was loaded.
                
                @Code(name: "_WorkflowItem.swift", file: "_WorkflowItem.swift", reset: true)
            }
            
            @Step {
                This metadata is the primary means by which items in a workflow are created. It holds onto a factory to create `AnyFlowRepresentable` references from passed in arguments. It also holds onto peripheral items like the persistence and launch style of a given `FlowRepresentable`.
                
                @Code(name: "FlowRepresentableMetadata.swift", file: "FlowRepresentableMetadata.swift", reset: true)
            }
            
            @Step {
                In the previous example it's noticeable that the factory and persistence require an `AnyWorkflow.PassedArgs` type. This type is almost identical to `Optional` but was specifically created to remove ambiguity. If we had used `Optional` it would've been unclear to consumers if an item in a workflow as passing `nil` as an argument, or if there were no arguments passed.
                
                @Code(name: "PassedArgs.swift", file: "PassedArgs.swift", reset: true)
            }
            
            @Step {
                Let's finally take a look at Workflow. In particular, notice that there are "actions" that Workflow handles. Launching, which involves loading the first `FlowRepresentable` that should load given the launch arguments. Proceeding, which is similar, but not identical to launching. Finally, backing up, which is a matter of finding the last loaded `FlowRepresentable`.
                
                Workflow knows how to handle persistence and can allow a `FlowRepresentable` that has a `shouldLoad` returning false to still mutate data.
                
                @Code(name: "Workflow.swift", file: "Workflow.swift", reset: true)
            }
        }
    }
    
    @Section(title: "FlowRepresentables, Orchestration Responder, and Type Erasure") {
        
        @ContentAndMedia {
            In this section you'll learn about FlowRepresentable, OrchestrationResponder, and our erased types.
        }
        
        @Steps {
            @Step {
                A `FlowRepresentable` is user-supplied. It's got an input, output, and shouldLoad method that Workflow depends on. In practice these end up being views most of the time. The `shouldLoad` method indicates whether the workflow should create and retain a new instance of this `FlowRepresentable`. 
                
                The Input and Output are strong types indicating what kind of data can be passed forward to the next `FlowRepresentable`. Since all args `Workflow` knows about are `AnyWorkflow.PassedArgs` there is a runtime check when an item proceeds using `proceedInWorkflow`.
                
                @Code(name: "FlowRepresentable.swift", file: "FlowRepresentable.swift", reset: true)
            }
            
            @Step {
                Workflow can be thought of as an orchestration engine. This is fairly typical for workflow systems. Workflows have several actions, launching, proceeding, backing up, etc... Those actions are all delegated to an OrchestrationResponder.
                
                You'll notice that the OrchestrationResponder is little more than something capable of receiving those events. We've built OrchestrationResponders for UIKit and SwiftUI.
                
                @Code(name: "OrchestrationResponder.swift", file: "OrchestrationResponder.swift", reset: true)
            }
            
            @Step {
                Workflow is highly dependent on type erasure. It's the only way to have a sequence of `FlowRepresentable`s. `AnyFlowRepresentable` not only erases the `FlowRepresentable` type, but it can also appropriately cast passed arguments and create a `FlowRepresentable` using it's `_factory` methods.
                
                @Code(name: "AnyFlowRepresentable.swift", file: "AnyFlowRepresentable.swift", reset: true)
            }
            
            @Step {
                AnyWorkflow is just an erased version of Workflow. Workflow really only has type information so that it can enforce compiler safety on calls to `thenProceed`. This erased version allows consumers to easily store workflows, or pass them around between parts of an application.
                
                @Code(name: "AnyWorkflow.swift", file: "AnyWorkflow.swift", reset: true)
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            What is the difference between a `FlowRepresentable` that has a `WorkflowInput` of `Any?` and a `FlowRepresentable` that has a `WorkflowInput` of `AnyWorkflow.PassedArgs`.

            @Choice(isCorrect: false) {
                `Any?` means any kind of data, including no data can be passed. `AnyWorkflow.PassedArgs` is equivalent, it's just not an optional.

                @Justification(reaction: "Try again!") {
                    Remember, `AnyWorkflow.PassedArgs` was deliberately built because an Optional wasn't enough to differentiate between "No data" and "Data, but it's nil".
                }
            }

            @Choice(isCorrect: true) {
                `Any?` means any kind of data, including nil can be passed to this `FlowRepresentable`. However, *something* must be passed forward. `AnyWorkflow.PassedArgs` means that some data (which can be nil) or no data at all (`AnyWorkflow.PassedArgs.none`) can be passed.

                @Justification(reaction: "That's right!") {
                    `AnyWorkflow.PassedArgs` is the only way to have a `FlowRepresentable` truly be able to interpret any situation, data being passed or no data being passed.
                }
            }

            @Choice(isCorrect: false) {
                `Any?` is broad enough to also include `AnyWorkflow.PassedArgs`. It's just a Swift way of saying "it doesn't matter what gets passed". `AnyWorkflow.PassedArgs` is more narrow, it means only certain `FlowRepresentable` types can pass data to this `FlowRepresentable.`
                
                @Justification(reaction: "Try again!") {
                    Remember, `AnyWorkflow.PassedArgs` was deliberately built because an Optional wasn't enough to differentiate between "No data" and "Data, but it's nil". While convention may lead you to believe that `Any?` is more broad than `AnyWorkflow.PassedArgs` that's not true in this context.
                }
            }
        }  
    }
}
